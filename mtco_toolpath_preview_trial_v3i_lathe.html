<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MTCO — Toolpath Preview (lathe view v3i)</title>
<style>
:root{
  --accent:#ff7a1a; --accent2:#ffa864;
  --bg:#0f1215; --panel:#161a1f; --card:#171b21; --border:#2b3139;
  --text:#e6e8eb; --muted:#8a9097; --radius:16px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--text);
     font:14px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}

header{position:sticky; top:0; z-index:5; background:linear-gradient(180deg,#181d24,#14181d); border-bottom:1px solid var(--border); box-shadow:0 6px 24px rgba(0,0,0,.25)}
.wrap{max-width:1220px;margin:0 auto;padding:12px 14px;display:grid;grid-template-columns:1fr auto;gap:12px;align-items:center}
.brand{display:flex;align-items:center;gap:12px}
.logo{width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 2px 12px rgba(255,122,26,.35)}
.title{font-weight:800;font-size:18px;letter-spacing:.4px}
.subtitle{color:#cfd3d8;font-size:12px}
.actions{display:flex;gap:8px;flex-wrap:wrap}
.btn{padding:8px 12px;border:1px solid #2b3139;border-radius:999px;background:#11161c;color:var(--text);cursor:pointer}
.btn.primary{background:var(--accent);border-color:var(--accent);color:#101114}
.btn:focus{outline:none;box-shadow:0 0 0 2px rgba(255,122,26,.35)}

main{max-width:1220px;margin:14px auto;padding:0 14px 18px;display:grid;gap:14px}
.grid{display:grid;gap:14px}
@media(min-width: 1000px){ .grid{ grid-template-columns: 520px 1fr } }
.card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:12px}
.card h2{margin:0 0 8px 0;font-size:14px;letter-spacing:.3px}
.controls{display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 8px 0}
label.small{font-size:12px;color:var(--muted)}
.tag{padding:4px 8px;border:1px solid #2b3139;border-radius:999px;font-size:12px;color:#cfd3d8}

textarea.code{width:100%;height:520px;padding:10px;border:1px solid #2b3139;border-radius:12px;background:#0f141a;color:#dfe3e7;resize:vertical}
textarea.code:focus{outline:none;box-shadow:0 0 0 2px rgba(255,122,26,.2);border-color:var(--accent)}

#warnings{font-size:12px;color:#ffcf99}
#canvasWrap{position:relative;height:600px;border-radius:12px;border:1px solid #2b3139;background:#0e1318;overflow:hidden}
canvas{display:block;width:100%;height:100%}
.overlay{position:absolute;top:8px;left:8px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.badge{padding:4px 8px;border:1px solid #2b3139;border-radius:999px;background:rgba(16,21,27,.85);font-size:12px;color:#e6e8eb}
.legend{position:absolute;bottom:8px;left:8px;font-size:12px;color:#cfd3d8;background:rgba(16,21,27,.8);border:1px solid #2b3139;border-radius:8px;padding:6px 8px}
.legend .sw{display:inline-block;width:20px;height:2px;vertical-align:middle;margin:0 6px 0 2px;background:#ff7a1a}
.legend .sw.rapid{background:#9aa3ad;outline:1px dashed #9aa3ad}

#status{font-size:12px;color:#aab0b7;margin-top:6px}
.aux{font-size:12px;color:#cfd3d8;opacity:.9}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="brand">
      <div class="logo"></div>
      <div>
        <div class="title">MTCO — Toolpath Preview</div>
        <div class="subtitle">Lathe view: Z0 at right face. Work left (Z−). Small Ø at Z0, grows as Z becomes more −. G02=CW, G03=CCW.</div>
      </div>
    </div>
    <div class="actions"><a class="btn" href="index.html">Home</a>
      <button class="btn primary" id="btnFit">Auto‑fit</button>
      <button class="btn" id="btnSample">Load sample</button>
      <button class="btn" id="btnSampleIK">Load I/K sample</button>
      <button class="btn" id="btnClear">Clear</button>
    </div>
  </div>
</header>

<main class="grid">
  <section class="card">
    <h2>Program</h2>
    <div class="controls">
      <label class="small"><input type="checkbox" id="diamMode" checked> Diameter mode (X/U as diameter)</label>
      <label class="small"><input type="checkbox" id="showRapids" checked> Show rapids</label>
      <span class="tag" id="unitTag">Units: mm (G21)</span>
    </div>
    <textarea id="code" class="code" spellcheck="false"></textarea>
    <div id="warnings"></div>
  </section>

  <section class="card">
    <h2>Preview</h2>
    <div id="canvasWrap">
      <div class="overlay">
        <span class="badge" id="cursorPos">X ?, Z ?</span>
        <span class="badge" id="selInfo">Line: —</span>
        <span class="aux">Convention: smallest Ø near Z0 (right), increasing Ø as you go left (Z−).</span>
      </div>
      <canvas id="view"></canvas>
      <div class="legend">
        <span class="sw"></span> Feed (G01/G02/G03) &nbsp; &nbsp; <span class="sw rapid"></span> Rapid (G00)
      </div>
    </div>
    <div id="status">Scroll to zoom, drag to pan. Click a segment to jump to its line. Click in code to highlight its segments.</div>
  </section>

  <section class="card">
    <h2>Cycle Time (estimate)</h2>
    <div class="controls">
      <label class="small">Feed rate (<span id="feedUnit">mm/min</span>)
        <input type="number" id="feedRate" value="200" min="0" step="1" style="margin-left:8px;width:120px">
      </label>
      <label class="small">Rapid rate (<span id="rapidUnit">mm/min</span>)
        <input type="number" id="rapidRate" value="6000" min="0" step="10" style="margin-left:8px;width:120px">
      </label>
    </div>
    <pre id="cycleOut" style="margin:0;background:#0f141a;border:1px solid #2b3139;border-radius:12px;padding:10px;white-space:pre-wrap">—</pre>
  
  <section class="card">
    <h2>Machine Limits</h2>
    <div class="controls">
      <label class="small">Max X travel (Ø, mm)
        <input type="number" id="limX" value="300" min="1" step="1" style="margin-left:8px;width:120px">
      </label>
      <label class="small">Z travel min (−mm)
        <input type="number" id="limZmin" value="-300" step="1" style="margin-left:8px;width:120px">
      </label>
      <label class="small">Z travel max (+mm)
        <input type="number" id="limZmax" value="20" step="1" style="margin-left:8px;width:120px">
      </label>
      <label class="small">Max spindle RPM
        <input type="number" id="limRPM" value="2500" min="1" step="10" style="margin-left:8px;width:120px">
      </label>
    </div>
    <div id="limitBadges" class="small" style="display:flex;flex-wrap:wrap;gap:8px"></div>
  </section>

  <section class="card" style="margin-top:12px">
    <h3>Cycle Time tips</h3>
    <ul class="small" style="margin:0 0 8px 16px">
      <li>Rapids are estimated from straight‑line distances (dash lines in the plot).</li>
      <li>Feeds include linear + arc lengths at programmed F (per block).</li>
      <li>If you use CSS mode (G96), RPM varies with diameter — verify limits manually.</li>
    </ul>
    <label class="small"><input type="checkbox" id="includeLeadIO" style="margin-right:8px">Include lead‑in/lead‑out in feed time (approx)</label>
  </section>

</section>

</main>

<script>
const codeEl = document.getElementById('code');
const diamEl = document.getElementById('diamMode');
const showRapidsEl = document.getElementById('showRapids');
const unitTag = document.getElementById('unitTag');
const warningsEl = document.getElementById('warnings');
const canvas = document.getElementById('view');
const wrap = document.getElementById('canvasWrap');
const cursorPos = document.getElementById('cursorPos');
const selInfo = document.getElementById('selInfo');
const btnFit = document.getElementById('btnFit');
const btnSample = document.getElementById('btnSample');
const btnClear = document.getElementById('btnClear');

// Globals
let segments = []; // {type:'rapid'|'line'|'arc', start:{x,z}, end:{x,z}, center?, cw?, line}
let bbox = null;   // {minx,maxx,minz,maxz}
let scale = 1, offx = 0, offz = 0; // world->screen transform
let mm = true;     // units flag (true=mm, false=inch)
let hoverSegmentIndex = -1;
let selectedLine = -1;

// --- Parsing ---
function parseNumber(tok){
  const v = parseFloat(tok);
  return (isFinite(v) ? v : null);
}
function tokenize(line){
  return line.toUpperCase().replace(/;.*$/,'').replace(/\(.*?\)/g,'').trim().split(/[\s,]+/).filter(s=>s.length);
}

function parseProgram(src){
  const lines = src.split(/\r?\n/);
  const outSegs = [];
  const warns = [];
  let pos = {x:0, z:0};
  let motion = null; // 'rapid'|'line'|'cw'|'ccw'
  mm = true;
  for(let idx=0; idx<lines.length; idx++){
    const raw = lines[idx];
    const toks = tokenize(raw);
    if(!toks.length){ continue; }
    let hasWord = false;
    let target = {x:null, z:null};
    let inc = {u:null, w:null};
    let arc = {i:null, k:null, r:null, cw:null};
    let setUnits = null;

    for(const t of toks){
      const c = t[0];
      const n = parseNumber(t.slice(1));
      if(n===null && c!=='(') continue;
      switch(c){
        case 'G':
          if(n===0){ motion='rapid'; hasWord=true; }
          else if(n===1){ motion='line'; hasWord=true; }
          else if(n===2){ motion='cw'; hasWord=true; }   // G02 = CW
          else if(n===3){ motion='ccw'; hasWord=true; }  // G03 = CCW
          else if(n===20){ setUnits=false; }
          else if(n===21){ setUnits=true; }
          break;
        case 'X': target.x = n; hasWord=true; break;
        case 'Z': target.z = n; hasWord=true; break;
        case 'U': inc.u = n; hasWord=true; break;
        case 'W': inc.w = n; hasWord=true; break;
        case 'I': arc.i = n; hasWord=true; break;
        case 'K': arc.k = n; hasWord=true; break;
        case 'R': arc.r = n; hasWord=true; break;
      }
    }
    if(setUnits!==null){ mm = setUnits; }
    if(!hasWord) continue;

    // Resolve coordinates (diameter vs radius)
    let x = pos.x, z = pos.z;
    const diam = diamEl.checked;
    if(target.x!==null){ x = diam ? target.x/2 : target.x; }
    if(target.z!==null){ z = target.z; }
    if(inc.u!==null){ x = x + (diam ? inc.u/2 : inc.u); }
    if(inc.w!==null){ z = z + inc.w; }

    if(motion==='rapid' || motion==='line'){
      if(x===pos.x && z===pos.z){ continue; }
      outSegs.push({type:(motion==='rapid'?'rapid':'line'), start:{...pos}, end:{x,z}, line: idx});
      pos = {x,z};
    }else if(motion==='cw' || motion==='ccw'){
      if(x===pos.x && z===pos.z){
        warns.push(`Line ${idx+1}: arc with no movement.`);
        continue;
      }
      const cw = (motion==='cw');
      let center = null;
      if(arc.i!==null || arc.k!==null){
        const cx = pos.x + (arc.i||0);
        const cz = pos.z + (arc.k||0);
        center = {x:cx, z:cz};
        const r0 = Math.hypot(pos.x - cx, pos.z - cz);
        const r1 = Math.hypot(x - cx, z - cz);
        if(Math.abs(r1 - r0) > 1e-3){
          warns.push(`Line ${idx+1}: arc end not on circle (Δ=${(r1-r0).toFixed(3)}).`);
        }
      }else if(arc.r!==null){
        // Robust R-arc: pick center that matches CW/CCW and minor/major (sign of R)
        const sx = pos.x, sz = pos.z;
        const ex = x, ez = z;
        const dx = ex - sx, dz = ez - sz;
        const chord = Math.hypot(dx, dz);
        if(chord < 1e-9){
          warns.push(`Line ${idx+1}: zero-length arc.`);
        }else{
          const rr = Math.abs(arc.r);
          if(rr < chord/2 - 1e-9){
            warns.push(`Line ${idx+1}: |R| too small for chord.`);
          }else{
            const midx = (sx+ex)/2, midz = (sz+ez)/2;
            const ux = dx/chord, uz = dz/chord;
            const px = -uz, pz = ux;
            const h = Math.sqrt(Math.max(0, rr*rr - (chord*chord)/4));
            const cand = [
              {x: midx + px*h, z: midz + pz*h},
              {x: midx - px*h, z: midz - pz*h}
            ];
            function normPi(a){ while(a<=-Math.PI) a+=2*Math.PI; while(a>Math.PI) a-=2*Math.PI; return a; }
            function sweepFor(center, cwFlag){
              const a0 = Math.atan2(sz - center.z, sx - center.x);
              const a1 = Math.atan2(ez - center.z, ex - center.x);
              const base = normPi(a1 - a0);
              if(cwFlag){ return (base<0)?base:base-2*Math.PI; }
              else      { return (base>0)?base:base+2*Math.PI; }
            }
            const wantMinor = (arc.r >= 0);
            let chosen = null;
            for(const c of cand){
              const sw = sweepFor(c, cw);
              const isMinor = Math.abs(sw) <= Math.PI + 1e-9;
              if((wantMinor && isMinor) || (!wantMinor && !isMinor)){ chosen = c; break; }
            }
            center = chosen || cand[0];
          }
        }
      }else{
        warns.push(`Line ${idx+1}: arc needs I/K or R.`);
      }
      if(center){
        outSegs.push({type:'arc', start:{...pos}, end:{x,z}, center, cw, line:idx});
        pos = {x,z};
      }
    }
  }
  warningsEl.innerHTML = warns.map(w=>`• ${w}`).join('<br>');
  unitTag.textContent = `Units: ${mm?'mm (G21)':'inch (G20)'}`;
  return {segs: outSegs, warns};
}

// --- View mapping (lathe): Z → right, X → up
function worldToScreen(pt){
  return { x: (pt.z * scale) + offx, z: (-pt.x * scale) + offz };
}
function screenToWorld(sx, sz){
  return { x: -((sz - offz)/scale), z: (sx - offx)/scale };
}

// Grid step heuristic
function pickGridStep(){
  const base = mm ? 1 : 0.1;
  const idealPx = 40;
  const s = idealPx/Math.max(1, scale);
  const raw = s/base;
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  for(const m of [1,2,5,10]){
    const gs = m*pow*base;
    if(gs >= s) return gs;
  }
  return 10*pow*base;
}

// --- Drawing ---
function draw(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = canvas.clientWidth, h = canvas.clientHeight;
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);

  // Compute world extents
  const z0 = -offx/scale, z1 = (w-offx)/scale;
  const x0 = -(0 - offz)/scale, x1 = -((h - offz)/scale);
  const zmin = Math.min(z0, z1), zmax = Math.max(z0, z1);
  const xmin = Math.min(x0, x1), xmax = Math.max(x0, x1);

  // grid
  ctx.save();
  ctx.strokeStyle = '#1d242c';
  ctx.lineWidth = 1;
  const gs = pickGridStep();
  const gz0 = Math.floor(zmin/gs)*gs;
  const gx0 = Math.floor(xmin/gs)*gs;
  for(let z=gz0; z<=zmax; z+=gs){
    const sx = z*scale + offx;
    ctx.beginPath(); ctx.moveTo(sx, -xmin*scale + offz); ctx.lineTo(sx, -xmax*scale + offz); ctx.stroke();
  }
  for(let x=gx0; x<=xmax; x+=gs){
    const sy = -x*scale + offz;
    ctx.beginPath(); ctx.moveTo(zmin*scale + offx, sy); ctx.lineTo(zmax*scale + offx, sy); ctx.stroke();
  }
  ctx.restore();

  // axes + origin
  const sx0 = 0*scale + offx;
  const sy0 = -0*scale + offz;
  ctx.strokeStyle = '#3a414b'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.moveTo(sx0, -xmin*scale + offz); ctx.lineTo(sx0, -xmax*scale + offz); ctx.stroke(); // Z axis
  ctx.beginPath(); ctx.moveTo(zmin*scale + offx, sy0); ctx.lineTo(zmax*scale + offx, sy0); ctx.stroke(); // X axis
  // origin
  ctx.fillStyle = '#ff7a1a'; ctx.beginPath(); ctx.arc(sx0, sy0, 3, 0, Math.PI*2); ctx.fill();
  // axis text
  ctx.fillStyle = '#aab0b7'; ctx.font = '12px ui-sans-serif';
  ctx.fillText('Z−', zmin*scale + offx + 6, sy0 - 6);
  ctx.fillText('Z+', zmax*scale + offx - 20, sy0 - 6);
  ctx.fillText('X+', sx0 + 6, -xmax*scale + offz + 14);
  ctx.fillText('X−', sx0 + 6, -xmin*scale + offz - 6);

  // segments
  const nearIdx = hoverSegmentIndex;
  for(let i=0;i<segments.length;i++){
    const s = segments[i];
    const isHover = (i===nearIdx) || (s.line===selectedLine);
    ctx.lineWidth = isHover ? 2.5 : 2;
    if(s.type==='rapid'){
      if(!showRapidsEl.checked) continue;
      ctx.setLineDash([8,8]);
      ctx.strokeStyle = isHover ? '#dfe6ee' : '#9aa3ad';
      lineSeg(ctx, s.start, s.end);
      ctx.setLineDash([]);
    }else if(s.type==='line'){
      ctx.strokeStyle = isHover ? '#ffd0a6' : '#ff7a1a';
      lineSeg(ctx, s.start, s.end);
    }else if(s.type==='arc'){
      ctx.strokeStyle = isHover ? '#ffd0a6' : '#ff7a1a';
      arcSeg(ctx, s);
    }
  }
}

function lineSeg(ctx, a, b){
  const p0 = worldToScreen(a), p1 = worldToScreen(b);
  ctx.beginPath(); ctx.moveTo(p0.x, p0.z); ctx.lineTo(p1.x, p1.z); ctx.stroke();
}

function arcSeg(ctx, s){
  const cx = s.center.x, cz = s.center.z;
  const r = Math.hypot(s.start.x-cx, s.start.z-cz);
  let a0 = Math.atan2(s.start.z - cz, s.start.x - cx);
  let a1 = Math.atan2(s.end.z - cz, s.end.x - cx);
  if(s.cw){ if(a1 > a0) a1 -= Math.PI*2; } else { if(a1 < a0) a1 += Math.PI*2; }
  const steps = Math.max(16, Math.floor(Math.abs(a1-a0) * r / Math.max(1, 2)));
  for(let i=0;i<=steps;i++){
    const t = i/steps;
    const ang = a0 + (a1-a0)*t;
    const x = cx + r * Math.cos(ang);
    const z = cz + r * Math.sin(ang);
    const p = worldToScreen({x,z});
    if(i===0){ ctx.beginPath(); ctx.moveTo(p.x, p.z); }
    else { ctx.lineTo(p.x, p.z); }
  }
  ctx.stroke();
}

// --- Distance helpers for picking ---
function distancePointToSegment(p, a, b){
  const vx = b.x - a.x, vz = b.z - a.z;
  const wx = p.x - a.x, wz = p.z - a.z;
  const c1 = vx*wx + vz*wz;
  if(c1<=0) return Math.hypot(p.x-a.x, p.z-a.z);
  const c2 = vx*vx + vz*vz;
  if(c2<=c1) return Math.hypot(p.x-b.x, p.z-b.z);
  const t = c1/c2;
  const px = a.x + t*vx, pz = a.z + t*vz;
  return Math.hypot(p.x-px, p.z-pz);
}

function distancePointToArc(p, s){
  const cx = s.center.x, cz = s.center.z;
  const r = Math.hypot(s.start.x-cx, s.start.z-cz);
  let a = Math.atan2(p.z - cz, p.x - cx);
  let a0 = Math.atan2(s.start.z - cz, s.start.x - cx);
  let a1 = Math.atan2(s.end.z - cz, s.end.x - cx);
  if(s.cw){
    if(a1 > a0) a1 -= Math.PI*2;
    if(a < a1) a = a1;
    if(a > a0) a = a0;
  }else{
    if(a1 < a0) a1 += Math.PI*2;
    if(a < a0) a = a0;
    if(a > a1) a = a1;
  }
  const px = cx + r * Math.cos(a), pz = cz + r * Math.sin(a);
  return Math.hypot(p.x - px, p.z - pz);
}

// --- Interaction ---
wrap.addEventListener('mousemove', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left, sz = e.clientY - rect.top;
  const wpt = screenToWorld(sx, sz);
  cursorPos.textContent = `X ${fmt(wpt.x)}, Z ${fmt(wpt.z)}`;
  // nearest segment
  let best = -1, bestd = 12/scale;
  for(let i=0;i<segments.length;i++){
    const s = segments[i];
    const d = (s.type==='arc') ? distancePointToArc(wpt, s) : distancePointToSegment(wpt, s.start, s.end);
    if(d < bestd){ bestd = d; best = i; }
  }
  hoverSegmentIndex = best;
  selInfo.textContent = (best>=0) ? `Line: ${segments[best].line+1}` : `Line: —`;
  draw();
});
wrap.addEventListener('click', ()=>{
  if(hoverSegmentIndex>=0){
    jumpToLine(segments[hoverSegmentIndex].line);
  }
});
let isPanning = false, last = {x:0,y:0};
wrap.addEventListener('mousedown', (e)=>{ isPanning=true; last={x:e.clientX,y:e.clientY}; });
window.addEventListener('mouseup', ()=> isPanning=false);
window.addEventListener('mousemove', (e)=>{
  if(!isPanning) return;
  const dx = e.clientX - last.x, dz = e.clientY - last.y;
  offx += dx; offz += dz; last={x:e.clientX,y:e.clientY}; draw();
});
wrap.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const sx = e.clientX - rect.left, sz = e.clientY - rect.top;
  const wx0 = (sx - offx)/scale, wz0 = (sz - offz)/scale;
  const factor = (e.deltaY<0) ? 1.1 : 0.9;
  scale *= factor;
  const sx1 = wx0*scale + offx, sz1 = wz0*scale + offz;
  offx += (sx - sx1);
  offz += (sz - sz1);
  draw();
}, {passive:false});

// Fit view
function autoFit(){
  if(!bbox){ return; }
  const w = canvas.clientWidth, h = canvas.clientHeight;
  const pad = 24;
  const dx = bbox.maxx - bbox.minx || 1;
  const dz = bbox.maxz - bbox.minz || 1;
  const sx = (w - 2*pad) / dz; // horizontal spans Z
  const sz = (h - 2*pad) / dx; // vertical spans X
  scale = Math.min(sx, sz);
  offx = -bbox.minz*scale + pad;   // left bound is min Z (more negative)
  offz = bbox.maxx*scale + pad;    // top bound: use max X so X+ is up
  draw();
}

// BBox
function recomputeBBox(){
  if(!segments.length){ bbox = {minx:-50,maxx:50,minz:-50,maxz:50}; return; }
  let minx=Infinity, maxx=-Infinity, minz=Infinity, maxz=-Infinity;
  function addPt(p){ if(p.x<minx)minx=p.x; if(p.x>maxx)maxx=p.x; if(p.z<minz)minz=p.z; if(p.z>maxz)maxz=p.z; }
  for(const s of segments){
    if(s.type==='rapid' && !showRapidsEl.checked) continue;
    addPt(s.start); addPt(s.end);
    if(s.type==='arc'){
      const cx=s.center.x, cz=s.center.z;
      const r = Math.hypot(s.start.x-cx, s.start.z-cz);
      const a0 = Math.atan2(s.start.z-cz, s.start.x-cx);
      let a1 = Math.atan2(s.end.z-cz, s.end.x-cx);
      const cw = s.cw;
      if(cw){ if(a1>a0) a1 -= Math.PI*2; } else { if(a1<a0) a1 += Math.PI*2; }
      const steps = 32;
      for(let i=0;i<=steps;i++){
        const t=i/steps; const ang=a0+(a1-a0)*t;
        addPt({x:cx+r*Math.cos(ang), z:cz+r*Math.sin(ang)});
      }
    }
  }
  if(!isFinite(minx)){ minx=-50; maxx=50; minz=-50; maxz=50; }
  bbox = {minx,maxx,minz,maxz};
}

// Build & init
function rebuild(){
  const {segs, warns} = parseProgram(codeEl.value);
  segments = segs;
  warningsEl.innerHTML = warns.map(w=>`• ${w}`).join('<br>');
  recomputeBBox();
  draw();
}

function fmt(v){ return (mm ? v.toFixed(3) : v.toFixed(4)); }

function getCaretLine(){
  const pos = codeEl.selectionStart || 0;
  const upTo = codeEl.value.slice(0,pos);
  return upTo.split(/\r?\n/).length - 1;
}

function jumpToLine(line){
  const lines = codeEl.value.split(/\r?\n/);
  let pos = 0;
  for(let i=0;i<line;i++) pos += lines[i].length+1;
  codeEl.focus();
  codeEl.setSelectionRange(pos, pos);
  selectedLine = line;
  draw();
}

// Events
codeEl.addEventListener('input', rebuild);
codeEl.addEventListener('keyup', ()=>{ selectedLine = getCaretLine(); draw(); });
codeEl.addEventListener('click', ()=>{ selectedLine = getCaretLine(); draw(); });

diamEl.addEventListener('change', rebuild);
showRapidsEl.addEventListener('change', ()=>{ recomputeBBox(); draw(); });
btnFit.addEventListener('click', autoFit);
btnClear.addEventListener('click', ()=>{ codeEl.value=''; rebuild(); });
btnSample.addEventListener('click', ()=>{
  codeEl.value = `%
(OD TURN — small at Z0, grows left)
G21 G18
G50 S2500
G97 S1200 M3
G0  X52 Z5
G1  Z0 F0.25
    X30
G02 X34 Z-2 R2
G1  Z-40
    X40
    Z-60
G0  X60 Z5
M30`;
  rebuild(); autoFit();
});

// Init
codeEl.value = `(Type or paste lathe code here)
Z increases to the right (away from chuck). Program cuts go left (Z−).
Smallest Ø is near Z0; diameters usually increase as Z goes negative.`;
rebuild();
setTimeout(()=>autoFit(), 50);

// --- Cycle time estimator ---
function normPi(a){ while(a<=-Math.PI) a+=2*Math.PI; while(a>Math.PI) a-=2*Math.PI; return a; }
function arcLength(seg){
  const r = Math.hypot(seg.start.x - seg.center.x, seg.start.z - seg.center.z);
  const a0 = Math.atan2(seg.start.z - seg.center.z, seg.start.x - seg.center.x);
  const a1 = Math.atan2(seg.end.z - seg.center.z, seg.end.x - seg.center.x);
  let d = normPi(a1 - a0);
  if(seg.cw){ if(d>0) d -= 2*Math.PI; } else { if(d<0) d += 2*Math.PI; }
  return Math.abs(d) * r;
}
function computeCycle(){
  const feed = parseFloat(document.getElementById('feedRate').value)||0;
  const rapid = parseFloat(document.getElementById('rapidRate').value)||0;
  let feedLen = 0, rapidLen = 0;
  for(const s of segments){
    if(s.type==='line'){
      const L = Math.hypot(s.end.x - s.start.x, s.end.z - s.start.z);
      if(L<=0) continue;
      if(s.type==='line'){ feedLen += L; }
    }else if(s.type==='arc'){
      const L = arcLength(s);
      if(L>0) feedLen += L;
    }else if(s.type==='rapid'){
      const L = Math.hypot(s.end.x - s.start.x, s.end.z - s.start.z);
      if(L>0) rapidLen += L;
    }
  }
  // Units label
  document.getElementById('feedUnit').textContent = (mm?'mm/min':'in/min');
  document.getElementById('rapidUnit').textContent = (mm?'mm/min':'in/min');
  const tFeed = feed>0 ? (feedLen / feed) : 0;
  const tRapid = rapid>0 ? (rapidLen / rapid) : 0;
  const t = tFeed + tRapid;
  const m = Math.floor(t);
  const ssec = Math.round((t - m)*60);
  document.getElementById('cycleOut').textContent = `${m}m ${ssec}s (feed ${feedLen.toFixed(mm?1:3)} ${mm?'mm':'in'}, rapid ${rapidLen.toFixed(mm?1:3)} ${mm?'mm':'in'})`;
}
// recompute when inputs change
const feedRateEl = document.getElementById('feedRate');
const rapidRateEl = document.getElementById('rapidRate');
if(feedRateEl && rapidRateEl){
  feedRateEl.addEventListener('input', computeCycle);
  rapidRateEl.addEventListener('input', computeCycle);
}

// Hook into rebuild() to update cycle time after drawing
const _rebuild = rebuild;
rebuild = function(){ _rebuild(); try{ computeCycle(); }catch(e){} };

// --- I/K sample loader ---
const btnSampleIK = document.getElementById('btnSampleIK');
if(btnSampleIK){
  btnSampleIK.addEventListener('click', ()=>{
    codeEl.value = `%
(OD TURN — small at Z0, grows left) (I/K arc version)
G21 G18
G50 S2500
G97 S1200 M3
G0  X52 Z5
G1  Z0 F0.25
    X30
(Replace R2 fillet with equivalent I/K centered at X32 Z-2)
G02 X34 Z-2 I2 K0
G1  Z-40
    X40
    Z-60
G0  X60 Z5
M30`;
    rebuild(); autoFit();
  });
}


// === Machine Limits & Tips ===
(function(){
  const codeEl = document.getElementById('code');
  const warnEl = document.getElementById('warnings');
  const lb = document.getElementById('limitBadges');
  const limX = document.getElementById('limX');
  const limZmin = document.getElementById('limZmin');
  const limZmax = document.getElementById('limZmax');
  const limRPM = document.getElementById('limRPM');
  const includeLeadIO = document.getElementById('includeLeadIO');

  function badge(text, kind){
    const span = document.createElement('span');
    const bg = kind==='warn' ? '#ffb02e22' : (kind==='danger' ? '#ff646422' : '#48c78e22');
    const br = kind==='warn' ? '#ffb02e' : (kind==='danger' ? '#ff6464' : '#48c78e');
    span.textContent = text;
    span.style.cssText = `padding:4px 8px;border:1px solid ${br};border-radius:999px;background:${bg};`;
    return span;
  }

  function getLastRPM(){
    const txt = (codeEl?.value||'').toUpperCase();
    const css = /G96/.test(txt);
    // Grab last explicit S value when using G97
    let rpm = null;
    if(!css){
      const m = txt.match(/G97[^\n]*?S(\d+)/g);
      if(m && m.length){
        const last = m[m.length-1];
        const sm = last.match(/S(\d+)/);
        if(sm) rpm = parseFloat(sm[1]);
      } else {
        // If no G97 near S, just take the last Sxxx
        const m2 = txt.match(/S(\d+)/g);
        if(m2 && m2.length){
          const last = m2[m2.length-1].match(/S(\d+)/);
          if(last) rpm = parseFloat(last[1]);
        }
      }
    }
    return {css, rpm};
  }

  // Draw overlay rectangle for machine window
  const _draw = draw;
  draw = function(){
    _draw();
    try {
      const maxX = parseFloat(limX.value)||0;
      const zmin = parseFloat(limZmin.value)||0;
      const zmax = parseFloat(limZmax.value)||0;
      // Convert world to screen using existing scale/offx/offz
      const sx0 = zmin*scale + offx;
      const sx1 = zmax*scale + offx;
      const sy0 = -0*scale + offz;        // X=0 bottom
      const sy1 = -maxX*scale + offz;     // X=maxX top
      ctx.save();
      ctx.strokeStyle = '#ffb02e';
      ctx.setLineDash([6,4]);
      ctx.lineWidth = 1.5;
      ctx.strokeRect(sx0, sy1, (sx1 - sx0), (sy0 - sy1));
      ctx.restore();
    } catch(e){ /* no-op */ }
  }

  function checkLimits(){
    if(!lb) return;
    lb.innerHTML = '';
    // bbox from global
    try{
      const xMax = bbox.maxx, xMin = bbox.minx;
      const zMax = bbox.maxz, zMin = bbox.minz;
      const maxX = parseFloat(limX.value)||0;
      const zmin = parseFloat(limZmin.value)||0;
      const zmax = parseFloat(limZmax.value)||0;

      // X (diameter) overrun
      if(xMax > maxX) lb.appendChild(badge(`X exceeds limit: ${xMax.toFixed(2)} > ${maxX}`, 'danger'));
      else lb.appendChild(badge(`X within limit (max Ø ${xMax.toFixed(2)} ≤ ${maxX})`, 'ok'));

      // Z range overrun
      if(zMin < zmin) lb.appendChild(badge(`Z− exceeds limit: ${zMin.toFixed(2)} < ${zmin}`, 'warn'));
      else lb.appendChild(badge(`Z− within limit (${zMin.toFixed(2)} ≥ ${zmin})`, 'ok'));
      if(zMax > zmax) lb.appendChild(badge(`Z+ exceeds limit: ${zMax.toFixed(2)} > ${zmax}`, 'warn'));
      else lb.appendChild(badge(`Z+ within limit (${zMax.toFixed(2)} ≤ ${zmax})`, 'ok'));

      // RPM check
      const {css, rpm} = getLastRPM();
      if(css){
        lb.appendChild(badge(`G96 CSS active — verify RPM limits at largest Ø`, 'warn'));
      } else if(rpm != null){
        const lim = parseFloat(limRPM.value)||0;
        if(rpm > lim) lb.appendChild(badge(`RPM exceeds limit: ${rpm} > ${lim}`, 'warn'));
        else lb.appendChild(badge(`RPM within limit (${rpm} ≤ ${lim})`, 'ok'));
      } else {
        lb.appendChild(badge(`No explicit RPM found`, 'warn'));
      }
    }catch(e){
      lb.appendChild(badge(`Limit check unavailable`, 'warn'));
    }
  }

  // Wire up
  ['input','change'].forEach(ev => {
    limX?.addEventListener(ev, ()=>{ draw(); checkLimits(); });
    limZmin?.addEventListener(ev, ()=>{ draw(); checkLimits(); });
    limZmax?.addEventListener(ev, ()=>{ draw(); checkLimits(); });
    limRPM?.addEventListener(ev, ()=>{ checkLimits(); });
    includeLeadIO?.addEventListener(ev, ()=>{ try{ computeCycle(); }catch(e){} });
  });

  // Hook after rebuild to recompute
  const _rb2 = rebuild;
  rebuild = function(){ _rb2(); try{ draw(); checkLimits(); computeCycle(); }catch(e){} };

  // Initial
  try{ checkLimits(); }catch(e){}
})();

</script>

<style>
  .back-home-fab {
    position: fixed; right: 14px; bottom: 14px;
    padding: 10px 14px; border-radius: 999px;
    background: var(--accent, #ff7a1a); color: #1b0f07;
    border: 1px solid rgba(0,0,0,.2); font-weight: 700; z-index: 9999;
  }
  @media (min-width: 961px){ .back-home-fab{ display:none; } }
</style>
<a class="back-home-fab" href="index.html" aria-label="Go to MTCO Home">Home</a>

</body>
</html>